inp w
mul x 0
add x z
mod x 26
div z 1
add x 12
eql x w   // x = 0 if first input was 12, never true.
eql x 0   // now x = 0 if input was _not_ 12 (so always)
mul y 0
add y 25
mul y x
add y 1 // y = 26 (unless first input was 12 I guess)
mul z y
mul y 0
add y w // ok, so copy first input to y
add y 4 // add 4 to first input
mul y x // set it to zero if first input was 12
add z y // copy (first input + 4) to z
inp w // Get next digit. At this point -> {x: 1, y: [0] + 4, z: [0] + 4}  <===>
mul x 0
add x z // Copy [0] + 4 to x as well.
mod x 26 // always noop I think
div z 1
add x 11 // x => [0] + 15
eql x w // Checks if the second digit = the first + 15. it never is tho
eql x 0 // Nots that, always true
mul y 0
add y 25 // y to 25
mul y x
add y 1 // y always to 26 I think
mul z y // z to 26 * ([0] + 4)
mul y 0
add y w
add y 10 // y = [1] + 10
mul y x
add z y // z = 26 * ([0] + 4) + [1] + 10
inp w // at this point { x = 1, y = [1] + 10, z = 26 * ([0] + 4) + [1] + 10}
mul x 0
add x z
mod x 26 // something here... I think we disregard the first digit entirely? oh no it's still in z nm
div z 1
add x 14 // x -> [1] + 24
eql x w // always false?
eql x 0 // always true
mul y 0
add y 25
mul y x
add y 1 //y -> 26
mul z y //z -> 26 * (26 * ([0] + 4) + [1] + 10)
mul y 0
add y w
add y 12 //y-> [2] + 12
mul y x
add z y //z -> 26 * (26 * ([0] + 4) + [1] + 10) + [2] + 12
inp w //[3]
mul x 0
add x z
mod x 26 x -> [2] + 12
div z 26 //!!! 26 * ([0] + 4) + [1] + 10, plus 1 if [2] + 12 > 26. NEVER TRUE
add x -6 x -> [2] + 6
eql x w // BRANCH: x => 
eql x 0 // BRANCH: x = [3] === [2] + 6 ? 0 : 1 
mul y 0
add y 25 // BRANCH: y = [3] === [2] + 6 ? 0 : 25 
mul y x
add y 1
mul z y // BRANCH: z gets multiplied by 26 unless [3] === [2] + 6
mul y 0
add y w
add y 14 // y -> [3] + 14
mul y x // assuming x == 0 at this point as [3] === [2] + 6, so y -> 0
add z y // noop
inp w [4]
mul x 0
add x z //x, z -> 26 * ([0] + 4) + [1] + 10
mod x 26 //x -> [1] + 10
div z 1
add x 15 // x-> [1] + 25
eql x w // x-> 0 always
eql x 0 // x -> 1 always
mul y 0
add y 25
mul y x
add y 1 // y -> 26
mul z y // 26 * (26 * ([0] + 4) + [1] + 10)
mul y 0
add y w
add y 6 // y -> [4] + 6
mul y x
add z y // z -> 26 * (26 * ([0] + 4) + [1] + 10) + [4] + 6
inp w [5]
mul x 0
add x z
mod x 26 // x -> [4] + 6
div z 1
add x 12 // [4] + 18
eql x w // always false
eql x 0 // x -> 1
mul y 0
add y 25
mul y x
add y 1 // y -> 26
mul z y // z -> 26 * (26 * (26 * ([0] + 4) + [1] + 10) + [4] + 6)
mul y 0
add y w
add y 16 // [5] + 16
mul y x
add z y // z -> 26 * (26 * (26 * ([0] + 4) + [1] + 10) + [4] + 6) + [5] + 16
inp w [6]
mul x 0
add x z
mod x 26 // x -> [5] + 16
div z 26 // z -> 26 * (26 * ([0] + 4) + [1] + 10) + [4] + 6
add x -9 // x -> [5] + 7
eql x w // BRANCH [6] == [5] + 7
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y // z gets bigger here unless [6] == [5] + 7
mul y 0
add y w // y -> [6]
add y 1 
mul y x
add z y // also here
inp w [7]
mul x 0
add x z // , z -> 26 * (26 * ([0] + 4) + [1] + 10) + [4] + 6
mod x 26 // x -> [4] + 6
div z 1
add x 14
eql x w
eql x 0 // x -> 1 always
mul y 0
add y 25
mul y x
add y 1
mul z y // z -> 26 * (26 * (26 * ([0] + 4) + [1] + 10) + [4] + 6)
mul y 0
add y w // [7]
add y 7 // [7] + 7
mul y x
add z y // z -> 26 * (26 * (26 * ([0] + 4) + [1] + 10) + [4] + 6) + [7] + 7
inp w [8]
mul x 0
add x z
mod x 26
div z 1
add x 14 // x -> [7] + 21
eql x w // false
eql x 0 // x -> 1
mul y 0
add y 25
mul y x
add y 1
mul z y // z-> 26 * (26 * (26 * (26 * ([0] + 4) + [1] + 10) + [4] + 6) + [7] + 7)
mul y 0
add y w
add y 8 [8] + 8
mul y x
add z y // z -> 26 * (26 * (26 * (26 * ([0] + 4) + [1] + 10) + [4] + 6) + [7] + 7) + [8] + 8
inp w [9]
mul x 0
add x z
mod x 26
div z 26 // z -> 26 * (26 * (26 * ([0] + 4) + [1] + 10) + [4] + 6) + [7] + 7
add x -5 // [8] + 3
eql x w // [9] == [8] + 3
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 11 // [9] + 11
mul y x
add z y
inp w [10]
mul x 0
add x z
mod x 26
div z 26
add x -9
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 8
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 26
add x -5
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 3
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 26
add x -2
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 1
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 26
add x -7
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 8
mul y x
add z y